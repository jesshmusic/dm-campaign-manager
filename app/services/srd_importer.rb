# frozen_string_literal: true

# Service class for importing SRD (System Reference Document) data from JSON files
# generated by the Python PDF parser. Supports both 2014 and 2024 editions.
#
# Usage:
#   SrdImporter.new(json_dir, edition).import_all
#   SrdImporter.new(json_dir, edition).import_type(:monsters)
#
class SrdImporter
  CONTENT_TYPES = %w[
    ability_scores
    dnd_classes
    items
    monsters
    profs
    races
    rules
    sections
    skills
    spells
  ].freeze

  attr_reader :json_dir, :edition

  def initialize(json_dir, edition = '2024')
    @json_dir = Pathname.new(json_dir)
    @edition = Editionable.normalize_edition(edition)
  end

  def import_all
    Rails.logger.info "Starting SRD import for edition #{edition} from #{json_dir}"
    CONTENT_TYPES.each do |type|
      import_type(type)
    end
    Rails.logger.info 'SRD import complete'
  end

  def import_type(type)
    type = type.to_s
    unless CONTENT_TYPES.include?(type)
      Rails.logger.warn "Unknown content type: #{type}"
      return
    end

    file = json_dir.join("#{type}.json")
    unless file.exist?
      Rails.logger.info "Skipping #{type}: file not found at #{file}"
      return
    end

    Rails.logger.info "Importing #{type} from #{file}..."
    data = JSON.parse(file.read)
    count = 0

    ActiveRecord::Base.transaction do
      data.each do |attrs|
        record = import_record(type, attrs)
        count += 1 if record&.persisted?
      end
    end

    Rails.logger.info "Imported #{count} #{type} records"
    count
  end

  private

  def import_record(type, attrs)
    model = model_for_type(type)
    return nil unless model

    # Ensure edition is set
    attrs = attrs.merge('edition' => edition)

    # Find by slug and edition, or initialize new
    slug = attrs['slug']
    record = model.find_or_initialize_by(slug: slug, edition: edition)

    # Handle nested associations
    nested_attrs = extract_nested_attrs(type, attrs)
    base_attrs = attrs.except(*nested_attrs.keys)

    record.assign_attributes(base_attrs)

    # Build nested associations
    build_nested_associations(record, type, nested_attrs)

    if record.save
      record
    else
      Rails.logger.warn "Failed to import #{type}: #{record.errors.full_messages.join(', ')}"
      nil
    end
  end

  def model_for_type(type)
    case type
    when 'ability_scores' then AbilityScore
    when 'dnd_classes' then DndClass
    when 'items' then Item
    when 'monsters' then Monster
    when 'profs' then Prof
    when 'races' then Race
    when 'rules' then Rule
    when 'sections' then Section
    when 'skills' then Skill
    when 'spells' then Spell
    else
      Rails.logger.warn "Unknown model for type: #{type}"
      nil
    end
  end

  def extract_nested_attrs(type, attrs)
    case type
    when 'monsters'
      attrs.slice(
        'speeds', 'senses', 'actions', 'special_abilities',
        'reactions', 'legendary_actions', 'saving_throws', 'skills',
        'damage_resistances', 'damage_immunities', 'damage_vulnerabilities',
        'condition_immunities'
      )
    when 'dnd_classes'
      attrs.slice(
        'dnd_class_levels', 'equipments', 'multi_classing',
        'prof_choices', 'spell_casting', 'starting_equipment_options',
        'saving_throws', 'skill_choices', 'proficiencies', 'starting_equipment'
      )
    when 'races'
      attrs.slice('ability_bonus_options', 'race_traits')
    when 'rules'
      attrs.slice('children')
    when 'spells'
      attrs.slice('dnd_class_ids', 'dnd_classes')
    when 'items'
      # Cost is an association, not a direct attribute
      # Also exclude other fields that don't match the model
      attrs.slice('cost', 'damage', 'armor_class')
    else
      {}
    end
  end

  def build_nested_associations(record, type, nested_attrs)
    case type
    when 'monsters'
      build_monster_associations(record, nested_attrs)
    when 'dnd_classes'
      build_dnd_class_associations(record, nested_attrs)
    when 'races'
      build_race_associations(record, nested_attrs)
    when 'rules'
      build_rule_associations(record, nested_attrs)
    when 'spells'
      build_spell_associations(record, nested_attrs)
    end
  end

  def build_monster_associations(monster, nested_attrs)
    # Clear existing associations for re-import
    monster.speeds.destroy_all if monster.persisted?
    monster.senses.destroy_all if monster.persisted?
    monster.monster_actions.destroy_all if monster.persisted?
    monster.special_abilities.destroy_all if monster.persisted?
    monster.reactions.destroy_all if monster.persisted?
    monster.legendary_actions.destroy_all if monster.persisted?
    monster.monster_proficiencies.destroy_all if monster.persisted?

    # Set string fields from arrays (damage types, condition immunities)
    monster.damage_resistances = (nested_attrs['damage_resistances'] || []).join(', ')
    monster.damage_immunities = (nested_attrs['damage_immunities'] || []).join(', ')
    monster.damage_vulnerabilities = (nested_attrs['damage_vulnerabilities'] || []).join(', ')
    monster.condition_immunities = (nested_attrs['condition_immunities'] || []).join(', ')

    # Build speeds
    (nested_attrs['speeds'] || []).each do |speed|
      monster.speeds.build(name: speed['name'], value: speed['value'])
    end

    # Build senses
    (nested_attrs['senses'] || []).each do |sense|
      monster.senses.build(name: sense['name'], value: sense['value'])
    end

    # Build actions
    (nested_attrs['actions'] || []).each do |action|
      monster.monster_actions.build(name: action['name'], desc: action['desc'])
    end

    # Build special abilities
    (nested_attrs['special_abilities'] || []).each do |ability|
      monster.special_abilities.build(name: ability['name'], desc: ability['desc'])
    end

    # Build reactions
    (nested_attrs['reactions'] || []).each do |reaction|
      monster.reactions.build(name: reaction['name'], desc: reaction['desc'])
    end

    # Build legendary actions
    (nested_attrs['legendary_actions'] || []).each do |action|
      monster.legendary_actions.build(name: action['name'], desc: action['desc'])
    end

    # Build proficiencies from saving throws and skills
    build_monster_proficiencies(monster, nested_attrs)
  end

  def build_monster_proficiencies(monster, nested_attrs)
    # Saving throws
    (nested_attrs['saving_throws'] || []).each do |save_name|
      prof = Prof.find_by('lower(name) = ?', "saving throw: #{save_name.to_s.downcase}")
      next unless prof

      ability_mod = begin
        monster.send(save_name.to_s.downcase.to_sym)
      rescue StandardError
        10
      end
      value = DndRules.ability_score_modifier(ability_mod) + monster.prof_bonus.to_i
      monster.monster_proficiencies.build(prof_id: prof.id, value: value)
    end

    # Skills
    (nested_attrs['skills'] || []).each do |skill_name|
      prof = Prof.find_by('lower(name) = ?', "skill: #{skill_name.to_s.downcase}")
      next unless prof

      monster.monster_proficiencies.build(prof_id: prof.id, value: monster.prof_bonus.to_i)
    end
  end

  def build_dnd_class_associations(dnd_class, nested_attrs)
    # DndClass has complex nested structure - defer to existing patterns
    # This would need expansion based on the exact JSON structure
  end

  def build_race_associations(race, nested_attrs)
    race.ability_bonus_options.destroy_all if race.persisted?
    race.race_traits.destroy_all if race.persisted?

    (nested_attrs['ability_bonus_options'] || []).each do |bonus|
      race.ability_bonus_options.build(ability: bonus['ability'], bonus: bonus['bonus'])
    end

    (nested_attrs['race_traits'] || []).each do |trait|
      race.race_traits.build(name: trait['name'], desc: trait['desc'])
    end
  end

  def build_rule_associations(rule, nested_attrs)
    # Rules can have child rules
    (nested_attrs['children'] || []).each do |child_attrs|
      child_slug = child_attrs['slug']
      child = Rule.find_or_initialize_by(slug: child_slug, edition: edition)
      child.assign_attributes(child_attrs.except('children').merge('edition' => edition))
      child.parent = rule
      child.save
    end
  end

  def build_spell_associations(spell, nested_attrs)
    # Link spells to classes via join table
    # First try dnd_class_ids (array of IDs)
    class_ids = nested_attrs['dnd_class_ids'] || []
    if class_ids.any?
      spell.dnd_class_ids = class_ids
      return
    end

    # Otherwise use dnd_classes string (e.g., "Wizard, Sorcerer")
    class_names = nested_attrs['dnd_classes']
    return unless class_names.is_a?(String) && class_names.present?

    # Find matching classes for this edition
    names = class_names.split(',').map(&:strip)
    classes = DndClass.where(edition: edition).where(name: names)
    spell.dnd_class_ids = classes.pluck(:id) if classes.any?
  end
end
